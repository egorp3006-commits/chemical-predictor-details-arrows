<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Інтерактивна таблиця — баланс реакції</title>

<style>
  :root{ --accent:#2a9df4; --pos:#1e6ed1; --neg:#d13b3b; --border:#9aa; --ui-bg:#fbfdff;}
  body{background:#f6f9fc; margin:0; padding:0; font-family:Arial, sans-serif;}
  .chem-wrap{max-width:1200px; margin:24px auto; background:#fff; padding:16px; border-radius:12px; box-shadow:0 2px 6px rgba(0,0,0,0.08);}
  .title{text-align:center; font-weight:700; margin-bottom:6px; font-size:20px;}
  .eq{ text-align:center; margin-bottom:12px; font-size:18px;}
  .formula-box{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .formula-part{display:inline-flex; align-items:center; gap:6px; font-weight:600;}

  table.chem{border-collapse:collapse; width:100%;}
  table.chem th, table.chem td{border:1px solid var(--border); padding:6px; text-align:center; min-width:46px; background:#fff; vertical-align:middle;}
  table.chem th{background:#e6f0fb; font-weight:700;}
  .elem-cell{background:#fafafa; font-weight:600;}
  input.num{width:100%; box-sizing:border-box; border:0; text-align:center; font-size:14px; padding:4px; background:transparent;}
  input.num:focus{outline:1px solid var(--accent); background:#eef7ff;}
  .coef{width:48px; box-sizing:border-box; padding:4px; text-align:center; border-radius:6px; border:1px solid #d7eafb; background:#f8fbff;}
  .mol-header{display:flex; flex-direction:column; gap:6px; align-items:center; justify-content:center;}
  .mol-name{font-weight:700; font-size:14px;}
  .mol-coef-label{font-size:11px; color:#555;}
  .rp-cell{min-height:36px; min-width:64px; display:flex; align-items:center; justify-content:center; background:#fff; transition:color 0.15s, background 0.15s;}
  .rp-zero{color:#333;}
  .rp-pos{color:var(--pos); font-weight:700;}
  .rp-neg{color:var(--neg); font-weight:700;}
  .note{font-size:13px; color:#555; text-align:center; margin-top:8px;}
  .mol-fallback{opacity:0.7; font-style:italic;}
  /* Забороняємо перенесення для заголовка R-P, щоб бути в один рядок */
  .rp-header{ white-space:nowrap; vertical-align:middle; }
  /* small screens */
  @media (max-width:880px){
    .coef{width:40px;}
    table.chem th, table.chem td{font-size:13px; padding:6px;}
    .formula-box{font-size:15px;}
  }

  /* --- Нові стилі для редактора схем --- */
  .scheme-wrap{margin-top:18px; padding:12px; border-radius:10px; background:var(--ui-bg); border:1px solid #e3eefc;}
  .scheme-toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px;}
  .scheme-toolbar select, .scheme-toolbar button, .scheme-toolbar input[type="number"]{padding:6px 8px; border-radius:6px; border:1px solid #d7eafb; background:#fff;}
  .scheme-area{position:relative; width:100%; height:420px; background:linear-gradient(180deg,#ffffff 0%, #f7fbff 100%); border:1px dashed #dbeaf8; border-radius:8px; overflow:hidden;}
  .scheme-canvas{position:absolute; left:0; top:0; width:100%; height:100%;}
  .scheme-elements{position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;}
  .formula-box-node{position:absolute; min-width:60px; padding:8px 10px; background:#fff; border:1px solid #cfe9ff; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.06); cursor:move; pointer-events:auto; user-select:none;}
  .formula-box-node[contenteditable="true"]{outline:none;}
  .formula-box-node .handle{position:absolute; right:6px; top:6px; width:10px; height:10px; background:#2a9df4; border-radius:50%; opacity:0.85; cursor:grab;}
  .formula-selected{box-shadow:0 0 0 3px rgba(42,157,244,0.12); border-color:var(--accent);}
  .scheme-footer{display:flex; justify-content:space-between; margin-top:8px; font-size:13px; color:#444;}
  .small-muted{font-size:12px; color:#666;}
  .control-group{display:flex; gap:6px; align-items:center;}
  .bond-line{stroke:#111; stroke-width:2;}
  .bond-line.double{stroke-width:2; stroke-linecap:butt;}
  .bond-line.triple{stroke-width:2;}
  .marker-arrow{fill:#111;}
  .stage-box{position:absolute; border:1px dashed #bcdcff; background:linear-gradient(180deg, rgba(42,157,244,0.03), rgba(42,157,244,0.01)); border-radius:8px; padding:6px; pointer-events:auto; cursor:move;}
  .btn{background:#fff; border:1px solid #d7eafb; padding:6px 10px; border-radius:6px; cursor:pointer;}
  .btn.primary{background:var(--accent); color:#fff; border-color:var(--accent);}
  .help-instructions{font-size:13px; color:#333;}
</style>
</head>
<body>

<div class="chem-wrap">
  <div class="title">Інтерактивна таблиця — баланс реакції</div>

  <div class="eq" aria-live="polite">
    <div class="formula-box" id="equation">
      <!-- динамічне рівняння -->
    </div>
    <div style="font-size:13px; color:#444;">(Реагенти зліва — Продукти справа)</div>
  </div>

  <!-- Єдина таблиця, щоб вирівнювання рядків було точним -->
  <table class="chem" id="mainTable" aria-label="Таблиця елементів і молекул">
    <!-- Групова шапка -->
    <thead>
      <tr>
        <th rowspan="2">Елемент</th>
        <th colspan="3">Реагенти</th>
        <th class="rp-header" rowspan="2">R − P</th>
        <th colspan="5">Продукти</th>
      </tr>
      <tr id="moleculeHeaders">
        <!-- тут будуть заголовки молекул (ім'я + input коефіцієнта) -->
      </tr>
    </thead>

    <tbody id="elementsBody">
      <!-- рядки елементів (заповнені скриптом) -->
    </tbody>
  </table>

  <div class="note">Змінюй числа індексів або коефіцієнти — рівняння та різниця (R − P) оновлюються автоматично. Якщо коефіцієнт 0 — молекулу не показуємо; 1 — цифру 1 не показуємо.</div>

  <!-- --- Новий блок редактора схем (розташований під таблицею, таблицю не міняєм) --- -->
  <div class="scheme-wrap" aria-label="Редактор схем реакцій">
    <div class="scheme-toolbar" role="toolbar" aria-label="Інструменти редактора">
      <div class="control-group">
        <label for="modeSelect">Режим:</label>
        <select id="modeSelect" aria-label="Вибір режиму">
          <option value="arrow">Стрілки</option>
          <option value="struct">Структурні формули</option>
          <option value="detailed">Детальні зв'язки</option>
          <option value="multistage">Багатостадійні ланцюги</option>
        </select>
      </div>

      <div class="control-group">
        <button id="addFormulaBtn" class="btn" aria-label="Додати формулу">Додати формулу</button>
        <button id="addArrowBtn" class="btn" aria-label="Додати стрілку">Додати стрілку</button>
        <button id="groupStageBtn" class="btn" aria-label="Групувати в етап">Створити етап</button>
      </div>

      <div class="control-group">
        <label for="arrowType">Тип стрілки</label>
        <select id="arrowType" aria-label="Тип стрілки">
          <option value="single">→ (пряма)</option>
          <option value="equil">⇌ (рівновага)</option>
          <option value="rev">⇄ (обернена)</option>
          <option value="fat">⇒ (потужна)</option>
        </select>
      </div>

      <div class="control-group">
        <label for="bondType">Тип зв'язку</label>
        <select id="bondType" aria-label="Тип зв'язку">
          <option value="single">Одинарний</option>
          <option value="double">Подвійний</option>
          <option value="triple">Потрійний</option>
        </select>
      </div>

      <div class="control-group">
        <label for="angleInput">Кут</label>
        <input id="angleInput" type="number" min="-180" max="180" value="0" aria-label="Кут стрілки (градуси)">
        <label><input id="snapToggle" type="checkbox" checked> Автопідгонка 15°</label>
      </div>

      <div class="control-group">
        <button id="clearBtn" class="btn" aria-label="Очистити схему">Очистити</button>
      </div>
    </div>

    <div class="scheme-area" id="schemeArea" role="application" aria-label="Поле побудови схеми">
      <!-- SVG для ліній і стрілок -->
      <svg id="schemeSvg" class="scheme-canvas" xmlns="http://www.w3.org/2000/svg" aria-hidden="false" focusable="false">
        <defs>
          <marker id="arrow-single" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
            <path d="M 0 0 L 10 5 L 0 10 z" class="marker-arrow"></path>
          </marker>
          <marker id="arrow-fat" viewBox="0 0 12 12" refX="12" refY="6" markerUnits="strokeWidth" markerWidth="10" markerHeight="8" orient="auto">
            <path d="M 0 0 L 12 6 L 0 12 z" class="marker-arrow" fill="#2a9df4"></path>
          </marker>
          <marker id="arrow-double" viewBox="0 0 10 10" refX="10" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
            <path d="M 0 0 L 10 5 L 0 10 z" class="marker-arrow"></path>
          </marker>
          <!-- small tail marker for reversed/bi-directional -->
          <marker id="arrow-small" viewBox="0 0 6 6" refX="6" refY="3" markerUnits="strokeWidth" markerWidth="6" markerHeight="6" orient="auto">
            <path d="M 0 0 L 6 3 L 0 6 z" class="marker-arrow"></path>
          </marker>
        </defs>

        <!-- group for bond/arrow lines -->
        <g id="svgLines"></g>
      </svg>

      <!-- DOM layer for draggable formula boxes -->
      <div class="scheme-elements" id="schemeElements" aria-live="polite"></div>
    </div>

    <div class="scheme-footer">
      <div class="help-instructions" id="schemeHelp">Натисни "Додати формулу", потім переміщуй її. Щоб додати стрілку — вибери "Додати стрілку" і натисни на джерело, потім на ціль.</div>
      <div class="small-muted">Перетягуй елементи, змінюй кут та тип стрілки; зв'язки оновлюються автоматично.</div>
    </div>
  </div>
  <!-- --- Кінець блоку редактора схем --- -->

</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // ---- існуючий код таблиці (не міняв) ----
  // Налаштування: список елементів і молекул
  const elements = ["H","C","O","N","P","S","F","Na","Ca"];
  const reactants = [
    {id:"h2o", label:"H2O"},
    {id:"co2", label:"CO2"},
    {id:"o2",  label:"O2"}
  ];
  const products = [
    {id:"h2",   label:"H2"},
    {id:"o3",   label:"O3"},
    {id:"h2co3",label:"H2CO3"},
    {id:"n2",   label:"N2"},
    {id:"nh3",  label:"NH3"}
  ];

  // Створимо заголовки з полями для коефіцієнтів
  const headerRow = document.getElementById("moleculeHeaders");
  function makeMolHeaderCell(mol){
    const th = document.createElement("th");
    th.innerHTML = `
      <div class="mol-header">
        <div class="mol-name" data-mol="${mol.id}" id="name_${mol.id}">${mol.label}</div>
        <div class="mol-coef-label">
          <input class="coef" aria-label="Коефіцієнт ${mol.id}" data-mol="${mol.id}" type="number" min="0" step="1" value="1">
        </div>
      </div>`;
    return th;
  }
  // Додаємо заголовки
  reactants.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));
  products.forEach(m => headerRow.appendChild(makeMolHeaderCell(m)));

  // Створимо тіло таблиці (рядок на кожен елемент)
  const body = document.getElementById("elementsBody");
  elements.forEach(elem => {
    const tr = document.createElement("tr");
    tr.innerHTML = `<td class="elem-cell">${elem}</td>`;

    // для кожного реагента — input індексів
    reactants.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell left" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="${m.id} ${elem}">`;
      tr.appendChild(td);
    });

    // R-P cell
    tr.innerHTML += `<td class="rp-cell" id="rp_${elem}">0</td>`;

    // для кожного продукту — input індексів
    products.forEach(m => {
      const td = document.createElement("td");
      td.innerHTML = `<input class="num cell right" data-mol="${m.id}" data-elem="${elem}" type="number" value="${defaultIndex(m.id, elem)}" min="0" step="1" aria-label="${m.id} ${elem}">`;
      tr.appendChild(td);
    });

    body.appendChild(tr);
  });

  // Значення за замовчуванням (від вашої початкової таблиці)
  function defaultIndex(mol, elem){
    const map = {
      h2o: {H:2,O:1},
      co2: {C:1,O:2},
      o2:  {O:2},
      h2:  {H:2},
      o3:  {O:3},
      h2co3:{H:2,C:1,O:3},
      n2:  {N:2},
      nh3: {N:1,H:3}
    };
    return (map[mol] && map[mol][elem]) ? map[mol][elem] : 0;
  }

  // Доступ до всіх input-ів
  function qAll(selector){ return Array.from(document.querySelectorAll(selector)); }

  // Створити формулу молекули як HTML, читаючи індекси з таблиці
  // Всі числа звичайного розміру: наприклад H2O, H2CO3, 2H2O (коефіцієнт перед формулою, теж звичайний розмір)
  function buildFormulaHTML(molId){
    let parts = [];
    elements.forEach(el => {
      const input = document.querySelector(`.cell[data-mol="${molId}"][data-elem="${el}"]`);
      const val = input ? Number(input.value) || 0 : 0;
      if(val > 0){
        parts.push(el + (val > 1 ? `${val}` : ""));
      }
    });
    // якщо немає елементів (вся формула "порожня") — показати id як запас
    if(parts.length === 0) return `<span class="mol-fallback">${molId}</span>`;
    return parts.join("");
  }

  // Побудова рівняння у верхній частині (реагенти = продукти) — числа у звичайному розмірі
  function buildEquation(){
    const leftParts = [];
    reactants.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Number(coefInput.value) || 0 : 0;
      if(coef === 0) return; // не показуємо
      const formula = buildFormulaHTML(m.id);
      const prefix = coef > 1 ? `${coef}` : "";
      leftParts.push(prefix + formula);
    });
    const rightParts = [];
    products.forEach(m => {
      const coefInput = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const coef = coefInput ? Number(coefInput.value) || 0 : 0;
      if(coef === 0) return;
      const formula = buildFormulaHTML(m.id);
      const prefix = coef > 1 ? `${coef}` : "";
      rightParts.push(prefix + formula);
    });

    const joiner = ' <span style="color:#666; font-weight:600">+</span> ';
    const leftHTML = leftParts.length ? leftParts.join(joiner) : '<span style="color:#999">—</span>';
    const rightHTML = rightParts.length ? rightParts.join(joiner) : '<span style="color:#999">—</span>';

    const eqBox = document.getElementById("equation");
    eqBox.innerHTML = `<div class="formula-part">${leftHTML}</div><div style="font-weight:700; padding:0 8px"> = </div><div class="formula-part">${rightHTML}</div>`;
  }

  // Обчислення різниці R - P по кожному елементу і оновлення стилю
  function updateDifference(){
    elements.forEach(elem => {
      let leftSum = 0;
      qAll(`.left[data-elem="${elem}"]`).forEach(input => leftSum += Number(input.value) || 0);
      let rightSum = 0;
      qAll(`.right[data-elem="${elem}"]`).forEach(input => rightSum += Number(input.value) || 0);
      const diff = leftSum - rightSum;
      const cell = document.getElementById(`rp_${elem}`);
      cell.textContent = diff;
      cell.classList.remove("rp-pos","rp-neg","rp-zero");
      if(diff > 0) cell.classList.add("rp-pos");
      else if(diff < 0) cell.classList.add("rp-neg");
      else cell.classList.add("rp-zero");
    });
  }

  // При зміні будь-чого: індексу або коефіцієнта — оновлюємо формули і різницю
  function onChangeHandler(){
    // Оновлюємо назви молекул над заголовками (щоб індекси відображались одразу)
    [...reactants, ...products].forEach(m => {
      const nameEl = document.getElementById(`name_${m.id}`);
      if(nameEl) nameEl.innerHTML = buildFormulaHTML(m.id);
    });

    buildEquation();
    updateDifference();
  }

  // Прив'язка подій
  qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
  qAll("input.coef, .coef").forEach(inp => inp.addEventListener("input", onChangeHandler));

  // Ініціалізація: знайдемо всі інпути .coef та .cell (які ми додали динамічно) і підвісимо події ще раз
  setTimeout(() => {
    qAll("input.num").forEach(inp => inp.addEventListener("input", onChangeHandler));
    qAll("input.coef").forEach(inp => inp.addEventListener("input", onChangeHandler));
    // Встановимо початкові коефіцієнти: якщо формула порожня — 0, інакше 1
    [...reactants, ...products].forEach(m => {
      const coef = document.querySelector(`.coef[data-mol="${m.id}"]`);
      const any = elements.some(el => {
        const elInput = document.querySelector(`.cell[data-mol="${m.id}"][data-elem="${el}"]`);
        return elInput && Number(elInput.value) > 0;
      });
      if(coef) coef.value = any ? coef.value || 1 : 0;
    });
    onChangeHandler();
  }, 0);

  // ---- Кінець існуючого коду таблиці ----


  // ---- Новий код: редактор схем зі стрілками та блоками ----
  const schemeArea = document.getElementById('schemeArea');
  const schemeSvg = document.getElementById('schemeSvg');
  const svgLines = document.getElementById('svgLines');
  const schemeElements = document.getElementById('schemeElements');

  const modeSelect = document.getElementById('modeSelect');
  const addFormulaBtn = document.getElementById('addFormulaBtn');
  const addArrowBtn = document.getElementById('addArrowBtn');
  const arrowTypeSelect = document.getElementById('arrowType');
  const bondTypeSelect = document.getElementById('bondType');
  const angleInput = document.getElementById('angleInput');
  const snapToggle = document.getElementById('snapToggle');
  const clearBtn = document.getElementById('clearBtn');
  const groupStageBtn = document.getElementById('groupStageBtn');
  const schemeHelp = document.getElementById('schemeHelp');

  let nodeIdCounter = 1;
  let arrowIdCounter = 1;
  let stageIdCounter = 1;

  const nodes = {}; // id -> {el, x, y, w, h}
  const arrows = {}; // id -> {from:nodeId, to:nodeId, svgEl, type, angle, bondType}
  const stages = {}; // id -> {el, children: [nodeIds]}

  // Utility: get bounding box of schemeArea (for coordinates)
  function getOffsetRect(elem){
    const rect = schemeArea.getBoundingClientRect();
    return {left: rect.left + window.scrollX, top: rect.top + window.scrollY};
  }

  // Create a draggable formula box
  function createFormulaBox(text = "CH3–CH2–OH", x = 40, y = 40){
    const id = 'node_' + (nodeIdCounter++);
    const div = document.createElement('div');
    div.className = 'formula-box-node';
    div.setAttribute('data-id', id);
    div.setAttribute('tabindex', 0);
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    div.innerHTML = `<div class="handle" title="Перетягнути" aria-hidden="true"></div>
                     <div class="formula-content" contenteditable="true" aria-label="Редагування формули">${escapeHtml(text)}</div>`;
    schemeElements.appendChild(div);
    // initial size
    const rect = div.getBoundingClientRect();
    nodes[id] = {el: div, x, y, w: rect.width || 120, h: rect.height || 36, selected: false};

    makeDraggable(div, id);
    div.addEventListener('click', (ev) => {
      ev.stopPropagation();
      handleNodeClick(id, ev);
    });

    // When contenteditable changes, update anchor positions for arrows
    const content = div.querySelector('.formula-content');
    content.addEventListener('input', () => updateArrowsForNode(id));

    return id;
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Draggable logic (supports pointer events)
  function makeDraggable(el, id){
    let isDown = false;
    let startX = 0, startY = 0, origX = 0, origY = 0;

    el.addEventListener('pointerdown', (e) => {
      if (e.button !== 0) return;
      isDown = true;
      el.setPointerCapture(e.pointerId);
      startX = e.clientX;
      startY = e.clientY;
      origX = nodes[id].x;
      origY = nodes[id].y;
      el.classList.add('dragging');
    });

    window.addEventListener('pointermove', (e) => {
      if(!isDown) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      let newX = origX + dx;
      let newY = origY + dy;
      // constrain to scheme area
      const pad = 8;
      const areaRect = schemeArea.getBoundingClientRect();
      newX = Math.max(pad, Math.min(newX, areaRect.width - nodes[id].w - pad));
      newY = Math.max(pad, Math.min(newY, areaRect.height - nodes[id].h - pad));
      nodes[id].x = newX;
      nodes[id].y = newY;
      el.style.left = newX + 'px';
      el.style.top = newY + 'px';
      updateArrowsForNode(id);
      // If node is part of a stage, update stage bounds (simple approach)
      updateStageBoundsForNode(id);
    });

    window.addEventListener('pointerup', (e) => {
      if(!isDown) return;
      isDown = false;
      try{ el.releasePointerCapture(e.pointerId); } catch(e){}
      el.classList.remove('dragging');
    });
  }

  // On scheme area click, clear selection (and handle creation flows)
  schemeArea.addEventListener('click', (e) => {
    clearSelection();
  });

  // Node click handler: used for arrow creation and selection
  let arrowCreationState = {active:false, from:null};
  function handleNodeClick(id, ev){
    const mode = modeSelect.value;
    if(mode === 'arrow' || ev.shiftKey){
      // arrow creation flow
      if(!arrowCreationState.active){
        arrowCreationState.active = true;
        arrowCreationState.from = id;
        schemeHelp.textContent = 'Оберіть ціль для стрілки (натисніть на іншу формулу), або клікніть ще раз на ту ж щоб скасувати.';
        highlightNode(id, true);
      } else {
        const from = arrowCreationState.from;
        const to = id;
        if(from && to && from !== to){
          createArrow(from, to, {type: arrowTypeSelect.value, bondType: bondTypeSelect.value, angle: Number(angleInput.value)});
        }
        highlightNode(from, false);
        arrowCreationState.active = false;
        arrowCreationState.from = null;
        schemeHelp.textContent = 'Готово. Додай ще або перетягни елементи.';
      }
      return;
    }

    // selection
    toggleSelectNode(id);
  }

  function highlightNode(id, on){
    const n = nodes[id];
    if(!n) return;
    if(on) n.el.classList.add('formula-selected');
    else n.el.classList.remove('formula-selected');
  }

  function toggleSelectNode(id){
    const n = nodes[id];
    if(!n) return;
    n.selected = !n.selected;
    if(n.selected) n.el.classList.add('formula-selected');
    else n.el.classList.remove('formula-selected');
  }

  function clearSelection(){
    Object.keys(nodes).forEach(k => {
      if(nodes[k].selected){
        nodes[k].selected = false;
        nodes[k].el.classList.remove('formula-selected');
      }
    });
    // cancel arrow creation
    if(arrowCreationState.active){
      highlightNode(arrowCreationState.from, false);
      arrowCreationState.active = false;
      arrowCreationState.from = null;
      schemeHelp.textContent = 'Скасовано вибір стрілки.';
    } else {
      schemeHelp.textContent = 'Натисни "Додати формулу" щоб створити нову, або "Додати стрілку" щоб малювати зв\'язки.';
    }
  }

  // Create arrow (SVG line with marker)
  function createArrow(fromId, toId, opts = {}){
    const id = 'arrow_' + (arrowIdCounter++);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute('data-id', id);
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute('class', 'bond-line');
    line.setAttribute('stroke-linecap', 'round');
    line.setAttribute('data-from', fromId);
    line.setAttribute('data-to', toId);
    // marker-end according to type
    const type = opts.type || 'single';
    const bondType = opts.bondType || 'single';
    const angle = (typeof opts.angle === 'number') ? opts.angle : 0;
    // choose marker
    let markerEnd = 'url(#arrow-single)';
    if(type === 'fat') markerEnd = 'url(#arrow-fat)';
    else if(type === 'equil' || type === 'rev') markerEnd = 'url(#arrow-double)';
    line.setAttribute('marker-end', markerEnd);
    if(type === 'equil' || type === 'rev'){
      // for bidirectional, also set marker-start for visual parity
      line.setAttribute('marker-start', 'url(#arrow-small)');
    }

    // For double/triple bonds we will create offset parallel lines if needed
    g.appendChild(line);
    svgLines.appendChild(g);
    arrows[id] = {from: fromId, to: toId, svgEl: g, type, angle, bondType, mainLine: line};
    updateArrowPosition(id);
    return id;
  }

  // Update position of a single arrow based on node positions
  function updateArrowPosition(arrowId){
    const arrow = arrows[arrowId];
    if(!arrow) return;
    const fromNode = nodes[arrow.from];
    const toNode = nodes[arrow.to];
    if(!fromNode || !toNode) return;
    // compute center points
    const fromRect = fromNode.el.getBoundingClientRect();
    const toRect = toNode.el.getBoundingClientRect();
    const areaRect = schemeArea.getBoundingClientRect();

    // compute coords relative to SVG (schemeArea origin)
    const fx = fromNode.x + fromNode.w/2;
    const fy = fromNode.y + fromNode.h/2;
    let tx = toNode.x + toNode.w/2;
    let ty = toNode.y + toNode.h/2;

    // if an explicit angle is set (non-zero), project target from source by angle and length roughly equal to distance
    const explicitAngle = Number(arrow.angle) || 0;
    if(explicitAngle !== 0){
      let len = Math.hypot(tx - fx, ty - fy);
      // if length is extremely small, set a default
      if(len < 32) len = 120;
      // compute rad (apply snapping if checked)
      let a = explicitAngle;
      if(snapToggle.checked){
        a = Math.round(a / 15) * 15;
      }
      const rad = a * Math.PI / 180;
      tx = fx + Math.cos(rad) * len;
      ty = fy + Math.sin(rad) * len;
    } else {
      // optionally snap angle between points
      let dx = tx - fx;
      let dy = ty - fy;
      if(snapToggle.checked){
        const ang = Math.atan2(dy, dx);
        const snapped = Math.round((ang * 180/Math.PI) / 15) * 15 * Math.PI/180;
        const r = Math.hypot(dx, dy);
        tx = fx + Math.cos(snapped)*r;
        ty = fy + Math.sin(snapped)*r;
      }
    }

    // convert to SVG coordinates (same coordinate space: schemeArea top-left = 0,0)
    arrow.mainLine.setAttribute('x1', fx);
    arrow.mainLine.setAttribute('y1', fy);
    arrow.mainLine.setAttribute('x2', tx);
    arrow.mainLine.setAttribute('y2', ty);

    // set style for bond type (single/double/triple)
    if(arrow.bondType === 'single'){
      arrow.mainLine.setAttribute('class', 'bond-line single');
      // remove duplicates if any
      removeExtraLines(arrow.svgEl);
    } else if(arrow.bondType === 'double'){
      arrow.mainLine.setAttribute('class', 'bond-line double');
      // create a parallel offset line
      createParallelLines(arrow, 2);
    } else if(arrow.bondType === 'triple'){
      arrow.mainLine.setAttribute('class', 'bond-line triple');
      createParallelLines(arrow, 3);
    }
  }

  function removeExtraLines(g){
    // keep only the first line child
    const lines = Array.from(g.querySelectorAll('line'));
    lines.forEach((ln, idx) => { if(idx > 0) ln.remove(); });
  }

  function createParallelLines(arrow, count){
    // remove old extras, then create count-1 parallel lines shifted perpendicular
    const g = arrow.svgEl;
    removeExtraLines(g);
    const x1 = Number(arrow.mainLine.getAttribute('x1'));
    const y1 = Number(arrow.mainLine.getAttribute('y1'));
    const x2 = Number(arrow.mainLine.getAttribute('x2'));
    const y2 = Number(arrow.mainLine.getAttribute('y2'));
    // direction vector
    const dx = x2 - x1, dy = y2 - y1;
    const len = Math.hypot(dx, dy) || 1;
    // unit perpendicular
    const ux = -dy / len;
    const uy = dx / len;
    // spacing
    const spacing = 6;
    const offsets = [];
    if(count === 2) offsets.push(spacing/2, -spacing/2);
    if(count === 3) offsets.push(0, spacing, -spacing);
    // keep main line as center (or one of lines). We'll remove main and recreate centered lines to ensure parallelism
    g.innerHTML = '';
    offsets.forEach((off, idx) => {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
      l.setAttribute('class', 'bond-line custom');
      l.setAttribute('stroke-linecap', 'round');
      l.setAttribute('marker-end', arrow.mainLine.getAttribute('marker-end') || 'url(#arrow-single)');
      if(arrow.type === 'equil' || arrow.type === 'rev') l.setAttribute('marker-start', 'url(#arrow-small)');
      const sx1 = x1 + ux*off;
      const sy1 = y1 + uy*off;
      const sx2 = x2 + ux*off;
      const sy2 = y2 + uy*off;
      l.setAttribute('x1', sx1);
      l.setAttribute('y1', sy1);
      l.setAttribute('x2', sx2);
      l.setAttribute('y2', sy2);
      g.appendChild(l);
    });
  }

  // Update all arrows that reference node id
  function updateArrowsForNode(nodeId){
    Object.keys(arrows).forEach(aid => {
      const ar = arrows[aid];
      if(ar.from === nodeId || ar.to === nodeId){
        updateArrowPosition(aid);
      }
    });
  }

  // Update stage bounds (simple bounding box) if node belongs to stage
  function updateStageBoundsForNode(nodeId){
    Object.keys(stages).forEach(sid => {
      const stage = stages[sid];
      if(stage.children.includes(nodeId)){
        // compute bounding box of child nodes
        let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
        stage.children.forEach(nid => {
          const n = nodes[nid];
          if(!n) return;
          minX = Math.min(minX, n.x);
          minY = Math.min(minY, n.y);
          maxX = Math.max(maxX, n.x + n.w);
          maxY = Math.max(maxY, n.y + n.h);
        });
        if(!isFinite(minX)) return;
        const pad = 12;
        stage.el.style.left = (minX - pad) + 'px';
        stage.el.style.top = (minY - pad) + 'px';
        stage.el.style.width = (maxX - minX + pad*2) + 'px';
        stage.el.style.height = (maxY - minY + pad*2) + 'px';
      }
    });
  }

  // UI bindings
  addFormulaBtn.addEventListener('click', () => {
    const mode = modeSelect.value;
    const defaultText = (mode === 'struct') ? 'H–O–H' : 'R';
    const id = createFormulaBox(defaultText, 40 + Math.random()*80, 40 + Math.random()*120);
    // focus editable area
    const content = nodes[id].el.querySelector('.formula-content');
    setTimeout(()=> content.focus(), 50);
  });

  addArrowBtn.addEventListener('click', () => {
    modeSelect.value = 'arrow';
    schemeHelp.textContent = 'Клікни на джерело, потім на ціль щоб створити стрілку.';
  });

  clearBtn.addEventListener('click', () => {
    // remove all nodes and svg lines
    Object.keys(nodes).forEach(k => nodes[k].el.remove());
    Object.keys(arrows).forEach(k => {
      const g = arrows[k].svgEl;
      if(g) g.remove();
    });
    Object.keys(stages).forEach(k => stages[k].el.remove());
    // clear objects
    for(const k in nodes) delete nodes[k];
    for(const k in arrows) delete arrows[k];
    for(const k in stages) delete stages[k];
    nodeIdCounter = arrowIdCounter = stageIdCounter = 1;
    schemeHelp.textContent = 'Схема очищена.';
  });

  // Angle input updates selected arrows (if any) or next created arrow
  angleInput.addEventListener('input', () => {
    const a = Number(angleInput.value) || 0;
    // update temporary arrow state if active
    if(arrowCreationState.active){
      // nothing to update visually until arrow is created
    }
    // update currently selected arrow(s)
    Object.keys(arrows).forEach(aid => {
      const ar = arrows[aid];
      // if either endpoint node is selected, update arrow angle as an affordance
      if(nodes[ar.from].selected || nodes[ar.to].selected){
        ar.angle = a;
        updateArrowPosition(aid);
      }
    });
  });

  bondTypeSelect.addEventListener('change', () => {
    // update arrows connected to selected nodes
    Object.keys(arrows).forEach(aid => {
      const ar = arrows[aid];
      if(nodes[ar.from].selected || nodes[ar.to].selected){
        ar.bondType = bondTypeSelect.value;
        updateArrowPosition(aid);
      }
    });
  });

  arrowTypeSelect.addEventListener('change', () => {
    // update marker for selected arrows
    Object.keys(arrows).forEach(aid => {
      const ar = arrows[aid];
      if(nodes[ar.from].selected || nodes[ar.to].selected){
        ar.type = arrowTypeSelect.value;
        // update marker attributes
        const m = (ar.type === 'fat') ? 'url(#arrow-fat)' : (ar.type === 'equil' || ar.type === 'rev') ? 'url(#arrow-double)' : 'url(#arrow-single)';
        // update underlying lines
        const lines = Array.from(ar.svgEl.querySelectorAll('line'));
        lines.forEach(l => {
          l.setAttribute('marker-end', m);
          if(ar.type === 'equil' || ar.type === 'rev') l.setAttribute('marker-start','url(#arrow-small)');
          else l.removeAttribute('marker-start');
        });
        updateArrowPosition(aid);
      }
    });
  });

  // Group selected nodes into a stage (draggable box)
  groupStageBtn.addEventListener('click', () => {
    const selected = Object.keys(nodes).filter(k => nodes[k].selected);
    if(selected.length === 0){
      schemeHelp.textContent = 'Оберіть елементи (клік по елементу) щоб згрупувати у етап.';
      return;
    }
    const sid = 'stage_' + (stageIdCounter++);
    const div = document.createElement('div');
    div.className = 'stage-box';
    div.setAttribute('data-id', sid);
    div.innerHTML = `<strong>Етап</strong>`;
    schemeElements.appendChild(div);
    stages[sid] = {el: div, children: selected.slice()};
    // style bounds
    updateStageBoundsForNode(selected[0]);
    // make stage draggable: moving stage moves children
    makeStageDraggable(div, sid);
    // deselect children
    selected.forEach(k => { nodes[k].selected = false; nodes[k].el.classList.remove('formula-selected'); });
    schemeHelp.textContent = 'Етап створено. Перетягни його разом з дітьми.';
  });

  function makeStageDraggable(el, sid){
    let isDown=false, startX=0, startY=0, origX=0, origY=0;
    el.addEventListener('pointerdown', (e) => {
      if(e.button !== 0) return;
      isDown = true;
      el.setPointerCapture(e.pointerId);
      const rect = el.getBoundingClientRect();
      const areaRect = schemeArea.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      origX = rect.left - areaRect.left;
      origY = rect.top - areaRect.top;
    });
    window.addEventListener('pointermove', (e) => {
      if(!isDown) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const newX = origX + dx;
      const newY = origY + dy;
      el.style.left = newX + 'px';
      el.style.top = newY + 'px';
      // move children accordingly
      const st = stages[sid];
      if(st){
        st.children.forEach(nid => {
          const nd = nodes[nid];
          nd.x += dx;
          nd.y += dy;
          nd.el.style.left = nd.x + 'px';
          nd.el.style.top = nd.y + 'px';
          updateArrowsForNode(nid);
        });
      }
      // update original origins for smooth dragging
      startX = e.clientX;
      startY = e.clientY;
      origX = newX;
      origY = newY;
    });
    window.addEventListener('pointerup', (e) => {
      if(!isDown) return;
      isDown = false;
      try{ el.releasePointerCapture(e.pointerId);}catch(e){}
    });
  }

  // simple helper: if window resizes, recompute node bboxes
  window.addEventListener('resize', () => {
    Object.keys(nodes).forEach(k => {
      const rect = nodes[k].el.getBoundingClientRect();
      nodes[k].w = rect.width;
      nodes[k].h = rect.height;
    });
    Object.keys(arrows).forEach(aid => updateArrowPosition(aid));
  });

  // Helper: when clicking outside elements, stop arrow creation
  addArrowBtn.addEventListener('click', () => {
    arrowCreationState.active = false;
    arrowCreationState.from = null;
  });

  // When clicking element while in arrow mode: handled in handleNodeClick

  // clicking on schemeSvg should not hijack selection
  schemeSvg.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  // ensure arrows update on init for potential new nodes
  function refreshAllArrows(){ Object.keys(arrows).forEach(aid => updateArrowPosition(aid)); }
  // set interval to keep alignment stable (cheap approach)
  setInterval(refreshAllArrows, 400);

  // ---- кінець нового коду редактора схем ----

});
</script>

</body>
</html>